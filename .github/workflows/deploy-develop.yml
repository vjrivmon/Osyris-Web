name: Deploy from Develop to Staging

on:
  push:
    branches:
      - develop
  workflow_dispatch:
    inputs:
      force_no_cache:
        description: 'Forzar limpieza de cachÃ© completa'
        required: false
        default: false
        type: boolean
      verify_staging:
        description: 'Verificar funcionamiento en staging'
        required: false
        default: true
        type: boolean

env:
  NODE_VERSION: '20.x'
  DEPLOY_PATH: /var/www/osyris-staging/current
  FRONTEND_PORT: 3001
  BACKEND_PORT: 5001
  DB_NAME: osyris_staging_db
  SERVER_USER: root
  SERVER_HOST: ${{ secrets.HETZNER_HOST }}

jobs:
  # Job de preparaciÃ³n y limpieza
  cleanup:
    name: Clean Environment & Cache
    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Clon completo para mejor limpieza

      - name: ðŸ§¹ Clean workspace thoroughly
        run: |
          echo "ðŸ§¹ Limpieza profunda del workspace..."
          # Limpiar cualquier cachÃ© previo
          rm -rf ~/.npm
          rm -rf node_modules/.cache
          npm cache clean --force || true

          # Eliminar directorios de build antiguos si existen
          rm -rf .next 2>/dev/null || true
          rm -rf build 2>/dev/null || true
          rm -rf api-osyris/.next 2>/dev/null || true
          rm -rf api-osyris/build 2>/dev/null || true

          # Mantener lockfiles para npm ci - NO eliminar
          echo "ðŸ“¦ Manteniendo lockfiles para npm ci..."

  # Job de testing mejorado
  test:
    name: Comprehensive Testing
    needs: cleanup
    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ“¦ Setup Node.js (con cachÃ© de lockfiles)
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: |
            package-lock.json
            api-osyris/package-lock.json

      - name: ðŸ“š Fresh dependencies installation
        run: |
          echo "ðŸ“¦ InstalaciÃ³n fresca de dependencias..."

          # Forzar instalaciÃ³n limpia
          rm -rf node_modules api-osyris/node_modules 2>/dev/null || true

          # Instalar frontend con npm ci (sin cachÃ©)
          npm ci --prefer-offline --no-audit --no-fund || npm install

          # Instalar backend con npm ci (sin cachÃ©)
          cd api-osyris
          rm -rf node_modules 2>/dev/null || true
          npm ci --prefer-offline --no-audit --no-fund || npm install
          cd ..

      - name: ðŸ” Validate dependencies
        run: |
          echo "ðŸ” Validando dependencias crÃ­ticas..."
          npm list --depth=0 || echo "âš ï¸ Algunas dependencias pueden faltar, continuando..."
          cd api-osyris
          npm list --depth=0 || echo "âš ï¸ Algunas dependencias pueden faltar, continuando..."
          cd ..

      - name: ðŸ§ª Run comprehensive tests
        run: |
          echo "ðŸ§ª Ejecutando suite de pruebas..."

          # Tests frontend
          echo "Testing frontend..."
          npm test -- --passWithNoTests --coverage --watchAll=false || true

          # Tests backend
          echo "Testing backend..."
          cd api-osyris
          npm test -- --passWithNoTests || true
          cd ..

      - name: ðŸ”¨ Fresh Build (sin cachÃ©)
        run: |
          echo "ðŸ—ï¸ Build fresco garantizado..."

          # Limpiar cualquier cachÃ© de build previo
          rm -rf .next out dist build 2>/dev/null || true
          cd api-osyris
          rm -rf .next out dist build 2>/dev/null || true
          cd ..

          # Forzar limpiar cachÃ© de Next.js
          npx next clean 2>/dev/null || true

          # Build frontend completo
          echo "Building frontend..."
          npm run build:frontend || npm run build

          # Build backend completo
          echo "Building backend..."
          cd api-osyris
          npm run build || echo "Backend build no disponible o fallÃ³"
          cd ..

          # Verificar que los builds se crearon correctamente
          if [ -d ".next" ]; then
            echo "âœ… Frontend build creado exitosamente"
            ls -la .next/ | head -10
          else
            echo "âŒ Frontend build fallÃ³"
            exit 1
          fi

      - name: ðŸ“Š Generate build info
        run: |
          echo "ðŸ“Š Generando informaciÃ³n del build..."
          BUILD_INFO="build-info-$(date +%Y%m%d_%H%M%S).json"

          cat > $BUILD_INFO << EOF
          {
            "build_timestamp": "$(date -Iseconds)",
            "commit_sha": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "actor": "${{ github.actor }}",
            "node_version": "$(node --version)",
            "npm_version": "$(npm --version)",
            "build_clean": true,
            "cache_disabled": true
          }
          EOF

          echo "Build info generated: $BUILD_INFO"
          cat $BUILD_INFO

  # Job de despliegue optimizado
  deploy:
    name: Deploy to Hetzner Production
    needs: test
    runs-on: ubuntu-latest

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.HETZNER_SSH_KEY }}

      - name: ðŸ“¦ Create fresh deployment package
        run: |
          echo "ðŸ“¦ Creando paquete de despliegue fresco..."

          # Excluir archivos innecesarios y cachÃ©
          tar -czf deploy.tar.gz \
            --exclude=.git \
            --exclude=logs \
            --exclude=.github \
            --exclude=node_modules \
            --exclude=api-osyris/node_modules \
            --exclude=.next \
            --exclude=api-osyris/.next \
            --exclude=build \
            --exclude=api-osyris/build \
            --exclude=dist \
            --exclude=api-osyris/dist \
            --exclude=deploy.tar.gz \
            --exclude=*.log \
            --exclude=.DS_Store \
            --exclude=Thumbs.db \
            . || true

          # Verificar que el archivo se creÃ³
          if [ ! -f deploy.tar.gz ]; then
            echo "âŒ Error: deploy.tar.gz no se creÃ³"
            exit 1
          fi

          echo "ðŸ“Š TamaÃ±o del paquete:"
          ls -lh deploy.tar.gz

      - name: ðŸš€ Deploy with Fresh Build Strategy
        run: |
          echo "ðŸš€ Iniciando despliegue con estrategia de build fresco..."

          # Crear directorio si no existe
          ssh -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}"

          # Subir archivos
          scp -o StrictHostKeyChecking=no deploy.tar.gz ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }}:${{ env.DEPLOY_PATH }}/

          # Script de deploy en servidor con limpieza garantizada
          ssh -o StrictHostKeyChecking=no ${{ env.SERVER_USER }}@${{ env.SERVER_HOST }} bash << 'ENDSSH'
          set -e
          cd ${{ env.DEPLOY_PATH }}

          echo "ðŸ§¹ LIMPIEZA PROFUNDA EN SERVIDOR"

          # Backup de seguridad con timestamp
          if [ -d "current" ]; then
            BACKUP_DIR="backup_$(date +%Y%m%d_%H%M%S)"
            echo "ðŸ’¾ Creando backup en $BACKUP_DIR..."
            cp -r current "$BACKUP_DIR"
            # Mantener solo los 5 backups mÃ¡s recientes
            ls -t | grep backup_ | tail -n +6 | xargs rm -rf 2>/dev/null || true
          fi

          # Backup de base de datos
          echo "ðŸ“Š Creando backup de base de datos..."
          docker exec osyris-db pg_dump -U osyris_user osyris_db | gzip > "backup_db_$(date +%Y%m%d_%H%M%S).sql.gz" || true
          ls -t backup_db_*.sql.gz 2>/dev/null | tail -n +11 | xargs rm -f 2>/dev/null || true

          # LIMPIEZA COMPLETA del directorio actual
          echo "ðŸ§¹ Eliminando directorio current completamente..."
          rm -rf current

          # Esperar a que se elimine completamente
          sleep 2

          # Crear directorio fresh
          mkdir -p current

          # Extraer nuevos archivos
          echo "ðŸ“¦ Extrayendo archivos frescos..."
          tar -xzf deploy.tar.gz -C current/
          rm deploy.tar.gz

          cd current

          echo "ðŸ§¹ LIMPIEZA DE CACHÃ‰ EN SERVIDOR"

          # Eliminar cualquier cachÃ© residual
          rm -rf .next 2>/dev/null || true
          rm -rf node_modules/.cache 2>/dev/null || true
          rm -rf api-osyris/.next 2>/dev/null || true
          rm -rf api-osyris/node_modules/.cache 2>/dev/null || true
          rm -rf build out dist 2>/dev/null || true
          rm -rf api-osyris/build api-osyris/out api-osyris/dist 2>/dev/null || true

          echo "ðŸ“¦ INSTALACIÃ“N FRESCA EN SERVIDOR"

          # Instalar dependencias frontend completamente frescas
          echo "Instalando dependencias frontend..."
          npm cache clean --force || true
          rm -rf node_modules
          npm ci --prefer-offline --no-audit --no-fund || npm install

          # Instalar dependencias backend completamente frescas
          echo "Instalando dependencias backend..."
          cd api-osyris
          npm cache clean --force || true
          rm -rf node_modules
          npm ci --prefer-offline --no-audit --no-fund || npm install
          cd ..

          echo "ðŸ—ï¸ BUILD EN SERVIDOR (FRESCO)"

          # Limpiar cachÃ© de Next.js
          npx next clean 2>/dev/null || true

          # Build frontend en servidor
          echo "Building frontend en servidor..."
          npm run build:frontend || npm run build

          # Verificar build exitoso
          if [ ! -d ".next" ]; then
            echo "âŒ BUILD FALLÃ“ - .next no existe"
            exit 1
          fi

          echo "âœ… Build frontend exitoso"

          # Limpiar devDependencies post-build
          echo "ðŸ§¹ Limpiando devDependencies..."
          npm prune --omit=dev
          cd api-osyris
          npm prune --omit=dev || true
          cd ..

          # Configurar .env del backend para STAGING
          cat > api-osyris/.env << 'ENVFILE'
          DATABASE_TYPE=postgres
          DB_HOST=localhost
          DB_PORT=5432
          DB_USER=osyris_user
          DB_PASSWORD=OsyrisDB2024!Secure
          DB_NAME=osyris_staging_db
          NODE_ENV=staging
          PORT=5001
          JWT_SECRET=osyrisScoutGroup2024SecretKey!Staging
          JWT_EXPIRES_IN=24h
          FRONTEND_URL=http://116.203.98.142:3001
          ALLOWED_ORIGINS=http://116.203.98.142:3001,http://localhost:3001
          STAGING_MODE=true
          ENVFILE

          echo "ðŸ˜ GESTIÃ“N DE CONTENEDORES DOCKER"

          # Detener contenedores antiguos de staging completamente
          echo "Deteniendo contenedores Docker antiguos de staging..."
          docker stop osyris-staging-frontend || true
          docker stop osyris-staging-backend || true
          docker rm osyris-staging-frontend || true
          docker rm osyris-staging-backend || true

          # Esperar a que se detengan completamente
          sleep 3

          # Verificar PostgreSQL estÃ¡ corriendo
          echo "Verificando PostgreSQL..."
          docker start osyris-db || docker-compose -f docker-compose.prod.yml up -d db

          # Esperar a que PostgreSQL estÃ© listo
          sleep 5

          echo "ðŸš€ INICIANDO SERVICIOS PM2"

          # Instalar/actualizar PM2
          if ! command -v pm2 &> /dev/null; then
            npm install -g pm2
          else
            npm update -g pm2 || true
          fi

          # Detener servicios PM2 existentes de STAGING
          pm2 stop osyris-staging-frontend || true
          pm2 stop osyris-staging-backend || true
          pm2 delete osyris-staging-frontend || true
          pm2 delete osyris-staging-backend || true

          # Limpiar puertos de staging
          fuser -k 3001/tcp 2>/dev/null || true
          fuser -k 5001/tcp 2>/dev/null || true

          # PequeÃ±a pausa para asegurar limpieza completa
          sleep 2

          # Iniciar frontend staging con PM2 (usando el build reciÃ©n creado)
          echo "Iniciando frontend staging en puerto 3001..."
          pm2 start "npx next start -p 3001" \
            --name "osyris-staging-frontend" \
            --cwd ${{ env.DEPLOY_PATH }} \
            --env NODE_ENV=staging

          # Iniciar backend staging con PM2
          echo "Iniciando backend staging en puerto 5001..."
          pm2 start ${{ env.DEPLOY_PATH }}/api-osyris/src/index.js \
            --name "osyris-staging-backend" \
            --cwd ${{ env.DEPLOY_PATH }}/api-osyris \
            --node-args="--env-file=${{ env.DEPLOY_PATH }}/api-osyris/.env" \
            --env NODE_ENV=staging

          # Guardar configuraciÃ³n PM2
          pm2 save
          pm2 startup || true

          # Mostrar estado final
          echo "âœ… DESPLIEGUE COMPLETADO:"
          pm2 list
          docker ps | grep osyris

          # Verificar que los procesos de STAGING estÃ¡n corriendo
          if ! pm2 list | grep -q "osyris-staging-frontend.*online"; then
            echo "âŒ Frontend staging no estÃ¡ online"
            pm2 logs osyris-staging-frontend --lines 20
            exit 1
          fi

          if ! pm2 list | grep -q "osyris-staging-backend.*online"; then
            echo "âŒ Backend staging no estÃ¡ online"
            pm2 logs osyris-staging-backend --lines 20
            exit 1
          fi

          echo "âœ… Todos los servicios de STAGING estÃ¡n online"
          ENDSSH

      - name: ðŸ§¹ Cleanup local
        run: rm -f deploy.tar.gz

      - name: â±ï¸ Wait for services to be ready
        run: |
          echo "â±ï¸ Esperando que los servicios estÃ©n completamente listos..."
          sleep 20

      - name: âœ… Comprehensive staging verification
        run: |
          echo "ðŸ” VerificaciÃ³n comprehensiva del despliegue en STAGING..."

          # Verificar frontend staging (HTTP puerto 3001)
          echo "Verificando frontend staging..."
          FRONTEND_STATUS=0
          for i in {1..5}; do
            echo "Intento $i de 5 para frontend staging..."
            if curl -f -s -o /dev/null -L http://116.203.98.142:3001; then
              echo "âœ… Frontend staging respondiendo correctamente"
              FRONTEND_STATUS=1
              break
            else
              echo "â³ Frontend staging no responde aÃºn, esperando 10s..."
              sleep 10
            fi
          done

          if [ $FRONTEND_STATUS -eq 0 ]; then
            echo "âŒ Frontend staging no responde despuÃ©s de 5 intentos"
            exit 1
          fi

          # Verificar backend API staging
          echo "Verificando backend API staging..."
          API_STATUS=0
          for i in {1..5}; do
            echo "Intento $i de 5 para API staging..."
            if curl -f -s -o /dev/null -L http://116.203.98.142:5001/api/health; then
              echo "âœ… Backend API staging respondiendo correctamente"
              API_STATUS=1
              break
            else
              echo "â³ API staging no responde aÃºn, esperando 10s..."
              sleep 10
            fi
          done

          if [ $API_STATUS -eq 0 ]; then
            echo "âš ï¸ Backend API staging no responde en /health, verificando endpoint alternativo..."
            # Verificar endpoint alternativo
            if curl -f -s -o /dev/null -L http://116.203.98.142:5001/api/usuarios; then
              echo "âœ… Backend staging responde en endpoint alternativo"
              API_STATUS=1
            else
              echo "âŒ Backend staging no responde"
              exit 1
            fi
          fi

          # VerificaciÃ³n de contenido especÃ­fico
          echo "Verificando contenido especÃ­fico en staging..."
          CONTENT_CHECK=$(curl -s -L http://116.203.98.142:3001 | grep -c "Osyris" || echo "0")
          if [ "$CONTENT_CHECK" -gt 0 ]; then
            echo "âœ… Contenido verificado - Osyris encontrado en pÃ¡gina principal de staging"
          else
            echo "âš ï¸ Advertencia: No se encontrÃ³ 'Osyris' en pÃ¡gina principal de staging"
          fi

      - name: ðŸ“Š Detailed staging deployment summary
        run: |
          echo "### ðŸ§ª Staging Deployment Summary - Fresh Build Strategy" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**InformaciÃ³n del Despliegue:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp:** $(date -Iseconds)" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ðŸ§ª STAGING" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Strategy:** Fresh (sin cachÃ©)" >> $GITHUB_STEP_SUMMARY
          echo "- **Server:** ${{ env.SERVER_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Acceso a STAGING:**" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŒ Frontend: http://116.203.98.142:3001" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”§ API: http://116.203.98.142:5001/api/health" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ³ BD Server: ${{ env.SERVER_HOST }}:5432 (DB: ${{ env.DB_NAME }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**âœ… Verificaciones Realizadas:**" >> $GITHUB_STEP_SUMMARY
          echo "- Limpieza completa de cachÃ©: âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- Build fresco en servidor: âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend staging respondiendo: âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- Backend API staging funcionando: âœ…" >> $GITHUB_STEP_SUMMARY
          echo "- Contenido verificado: âœ…" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŽ‰ **Despliegue a STAGING completado con Ã©xito!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Nota:** Este es el entorno de STAGING. Para desplegar a PRODUCCIÃ“N, mergea a \`main\`." >> $GITHUB_STEP_SUMMARY

  # Job de notificaciÃ³n
  notify:
    name: Send notifications
    needs: deploy
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: ðŸ“¬ Staging deploy notification
        run: |
          echo "## ðŸ§ª NotificaciÃ³n de Despliegue a STAGING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            echo "âœ… **Despliegue exitoso desde develop a STAGING**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Enlaces de acceso a STAGING:**" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸŒ Frontend: http://116.203.98.142:3001" >> $GITHUB_STEP_SUMMARY
            echo "- ðŸ”§ API Health: http://116.203.98.142:5001/api/health" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Estrategia utilizada:** Build fresco sin cachÃ©" >> $GITHUB_STEP_SUMMARY
            echo "**Environment:** STAGING (para testing)" >> $GITHUB_STEP_SUMMARY
            echo "**Timestamp:** $(date -Iseconds)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âž¡ï¸ **PrÃ³ximo paso:** Testear en staging y mergear a \`main\` para desplegar a producciÃ³n" >> $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Despliegue a STAGING fallÃ³ - revisar logs**" >> $GITHUB_STEP_SUMMARY
            echo "**AcciÃ³n requerida:** Investigar logs del job 'deploy'" >> $GITHUB_STEP_SUMMARY
          fi